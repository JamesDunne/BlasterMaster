#include "common.h"
#include "bm.h"
#include "opengl.h"
#include "newmap.h"

SDL_Surface		*fgsprites[16];
SDL_Surface		*bgsprites[16];

SDL_Surface	*srfVideo;
Uint32		curticks;
int			fullscreen, level_loaded;

// -- Main sprite routines --
int put_sprite(fixed x,fixed y,int m,GLuint sprite)
{
	SDL_Rect	src, dst;
	
	// Where to find the source sprite:
	src.x = (sprite & 0x0F) << 4;
	src.y = (sprite >> 4) << 4;
	src.w = 16;
	src.h = 16;
	
	// Where to blit the surface on the video:
	dst.x = (long)x;
	dst.y = (long)y;
	dst.w = 16;
	dst.h = 16;
	
	// Blit the surface:
	SDL_BlitSurface(fgsprites[m], &src, SDL_GetVideoSurface(), &dst);
	
	return 0;
}

// Flip horizontally:
int put_sprite_hflip(fixed x,fixed y,int m,GLuint sprite)
{
/*	GLfloat	tx1, ty1, tx2, ty2;

	tx1 = (sprite & 0x0F) * 0.0625f;
	ty1 = (sprite >> 4) * 0.0625f;
	tx2 = tx1 + 0.0625f;
	ty2 = ty1 + 0.0625f;

	glBindTexture(GL_TEXTURE_2D, fgsprites[m]);

	glPushMatrix();
	glTranslatef(x, y, 0);
	// Draw the sprite:
	glBegin(GL_QUADS);
	glTexCoord2f(tx2, ty1); glVertex2i(0 , 0 );
	glTexCoord2f(tx1, ty1); glVertex2i(16, 0 );
	glTexCoord2f(tx1, ty2); glVertex2i(16, 16);
	glTexCoord2f(tx2, ty2); glVertex2i(0 , 16);
	glEnd();
	glPopMatrix();
*/
	return 0;
}

// Flip vertically
int put_sprite_vflip(fixed x,fixed y,int m,GLuint sprite)
{
/*	GLfloat	tx1, ty1, tx2, ty2;

	tx1 = (sprite & 0x0F) * 0.0625f;
	ty1 = (sprite >> 4) * 0.0625f;
	tx2 = tx1 + 0.0625f;
	ty2 = ty1 + 0.0625f;

	glBindTexture(GL_TEXTURE_2D, fgsprites[m]);

	glPushMatrix();
	glTranslatef(x, y, 0);
	// Draw the sprite:
	glBegin(GL_QUADS);
	glTexCoord2f(tx1, ty2); glVertex2i(0 , 0 );
	glTexCoord2f(tx2, ty2); glVertex2i(16, 0 );
	glTexCoord2f(tx2, ty1); glVertex2i(16, 16);
	glTexCoord2f(tx1, ty1); glVertex2i(0 , 16);
	glEnd();
	glPopMatrix();
*/
	return 0;
}

// Flip horizontally and vertically:
int put_sprite_hvflip(fixed x,fixed y,int m,GLuint sprite)
{
/*
	GLfloat	tx1, ty1, tx2, ty2;

	tx1 = (sprite & 0x0F) * 0.0625f;
	ty1 = (sprite >> 4) * 0.0625f;
	tx2 = tx1 + 0.0625f;
	ty2 = ty1 + 0.0625f;

	glBindTexture(GL_TEXTURE_2D, fgsprites[m]);

	glPushMatrix();
	glTranslatef(x, y, 0);
	// Draw the sprite:
	glBegin(GL_QUADS);
	glTexCoord2f(tx2, ty2); glVertex2i(0 , 0 );
	glTexCoord2f(tx1, ty2); glVertex2i(16, 0 );
	glTexCoord2f(tx1, ty1); glVertex2i(16, 16);
	glTexCoord2f(tx2, ty1); glVertex2i(0 , 16);
	glEnd();
	glPopMatrix();
*/
	return 0;
}

int put_bgtile(fixed x, fixed y, int m, unsigned char t, int bg) {
	SDL_Rect	src, dst;
	
	src.x = (t >> 4) << 4;
	src.y = (t & 0x0F) << 4;
	src.w = src.h = 16;
	
	dst.x = (long)x;
	dst.y = (long)y;
	dst.w = dst.h = 16;
	
	SDL_BlitSurface(bgsprites[m & 3], &src, SDL_GetVideoSurface(), &dst);
	
	return 0;
}

void Draw2x2BGTile(fixed x, fixed y, int t, int bg) {
	int	m = map.mapflags[t];
	put_bgtile(x   , y   , m, map.map2x2[(t<<2)+0], bg);
	put_bgtile(x+16, y   , m, map.map2x2[(t<<2)+1], bg);
	put_bgtile(x   , y+16, m, map.map2x2[(t<<2)+2], bg);
	put_bgtile(x+16, y+16, m, map.map2x2[(t<<2)+3], bg);
}

int InitTextures() {
	int		i, j;
	char	filename[256];
	
	for (j=0; j<map.numtextures; ++j) {
		bgsprites[j] = IMG_Load(map.texturefile[j]);
		if (bgsprites[j] == NULL) {
			fprintf(stderr, "Couldn't find '%s'\n", map.texturefile[j]);
			return -1;
		}
	}
	
	return 0;
}

void LoadTexture(int page, const char *filename) {
	int			i, j;
	
	if ((page < 0) || (page > 15)) return;
	
	// Free old texture:
	if (fgsprites[page] != NULL) {
		SDL_FreeSurface(fgsprites[page]);
		fgsprites[page] = NULL;
	}
	
	// Create new texture:
	fgsprites[page] = IMG_Load(filename);
	if (fgsprites[page] == NULL) {
		fprintf(stderr, "Couldn't find '%s'\n", filename);
		exit(-1);
		return;
	}
}

void FreeTextures() {
	int	i;
	for (i=0; i<16; ++i)
		if (fgsprites[i] != NULL) {
			SDL_FreeSurface(fgsprites[i]);
			fgsprites[i] = 0;
		}
		
	for (i=0; i<4; ++i) {
		SDL_FreeSurface(bgsprites[i]);
		bgsprites[i] = 0;
	}
}

void InitGL(int Width, int Height) {
/*	glViewport(0, 0, Width, Height);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, Width, Height, 0);

	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);			  // Black Background
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
*/
}

void sys_init(int argc, char **argv) {
	int i, w, h;
	unsigned long sdlflags;
    Uint32 rmask, gmask, bmask, amask;
	
	/* Initialize SDL for video output */
	if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) {
		fprintf(stderr, "Unable to initialize SDL: %s\n", SDL_GetError());
		exit(1);
	}
	
	// Enable the joystick subsystem:
	SDL_InitSubSystem(SDL_INIT_JOYSTICK);
	
	// Default resolution:
	screen_w = 640; screen_h = 480;
	
	// Scan program arguments:
	sdlflags = SDL_DOUBLEBUF | SDL_HWSURFACE | SDL_HWACCEL;
	for (i=1; i<argc; ++i) {
		if (strcmp(argv[i], "-fs") == 0) sdlflags |= SDL_FULLSCREEN;
		if (strcmp(argv[i], "-w") == 0) screen_w = atoi(argv[i+1]);
		if (strcmp(argv[i], "-h") == 0) screen_h = atoi(argv[i+1]);
	}
	
	/* Create an SDL full-screen context */
	srfVideo = SDL_SetVideoMode(screen_w, screen_h, 24, sdlflags);
	if ( srfVideo == NULL ) {
		fprintf(stderr, "Unable to create SDL screen: %s\n", SDL_GetError());
		SDL_Quit();
		exit(2);
	}
	
	// Set the title bar in environments that support it:
	SDL_WM_SetCaption("Blaster Master Engine Test", NULL);
	
	// Initialize OpenGL:
	InitGL(screen_w, screen_h);
	
	level_loaded = 0;
	
	// Scan for joysticks:
	printf("%i joysticks were found.\n\n", SDL_NumJoysticks() );
	if (SDL_NumJoysticks() > 0) {
		printf("The names of the joysticks are:\n");
		
		SDL_JoystickEventState(SDL_ENABLE);
		
		for( i=0; i < SDL_NumJoysticks(); i++ )
		{
			SDL_Joystick	*curjoy = SDL_JoystickOpen(i);
			printf("	%s (%d buttons, %d axes, %d hats, %d balls)\n", SDL_JoystickName(i),
				SDL_JoystickNumButtons(curjoy), SDL_JoystickNumAxes(curjoy),
				SDL_JoystickNumHats(curjoy), SDL_JoystickNumBalls(curjoy));
		}
	}
	
	// Clear texture indicies:	
	for (i=0; i<16; ++i)
		fgsprites[i] = bgsprites[i] = NULL;
	
	// Don't show the mouse cursor in full screen:
	if (sdlflags & SDL_FULLSCREEN)
		SDL_ShowCursor(0);
};

void sys_close() {
	if (level_loaded) FreeTextures();

	SDL_WM_GrabInput(SDL_GRAB_OFF);
	SDL_ShowCursor(1);

	SDL_JoystickEventState(SDL_DISABLE);

	SDL_Quit();
}

void sys_togglefullscreen() {

};

void sys_clearscreen() {
	curticks = SDL_GetTicks();
}

void sys_updatescreen() {
	// About 60 fps:	(60fps = 16.667 ms/frame)
	//while (SDL_GetTicks() - curticks <= 16);

	// Flip buffers:
	SDL_Flip(srfVideo);
	//SDL_UpdateRect(srfVideo, 0, 0, 0, 0);
};

void sys_eventloop(Uint8 *control_keys) {
	// Poll SDL events:
	SDL_Event event;
	while ( SDL_PollEvent(&event) ) {
		if ( event.type == SDL_QUIT ) {
			quit = 1;
		}
		if ( event.type == SDL_KEYDOWN ) {
			switch ( event.key.keysym.sym ) {
				case SDLK_ESCAPE: quit = 1; break;
				case SDLK_LEFT:		*control_keys |= BUT_LEFT; break;
				case SDLK_RIGHT:	*control_keys |= BUT_RIGHT; break;
				case SDLK_UP:		*control_keys |= BUT_UP; break;
				case SDLK_DOWN:		*control_keys |= BUT_DOWN; break;
				case SDLK_x:		*control_keys |= BUT_SHOOT; break;
				case SDLK_z:		*control_keys |= BUT_JUMP; break;
				case SDLK_a:		*control_keys |= BUT_SWITCH; break;
				case SDLK_RETURN:
					if ( event.key.keysym.mod & KMOD_ALT )
						sys_togglefullscreen();
					else
						*control_keys |= BUT_PAUSE;
					break;
				case SDLK_F1:		LoadLevel("maps/map00.bma"); break;
				case SDLK_F2:		LoadLevel("maps/map01.bma"); break;
				case SDLK_F3:		LoadLevel("maps/map02.bma"); break;
				case SDLK_F4:		LoadLevel("maps/map03.bma"); break;
				case SDLK_F5:		LoadLevel("maps/map04.bma"); break;
				case SDLK_F6:		LoadLevel("maps/map05.bma"); break;
				case SDLK_F7:		LoadLevel("maps/map06.bma"); break;
				case SDLK_F8:		LoadLevel("maps/map07.bma"); break;
			}
		}
		if ( event.type == SDL_KEYUP ) {
			switch ( event.key.keysym.sym ) {
				case SDLK_LEFT:		*control_keys &= ~BUT_LEFT; break;
				case SDLK_RIGHT:	*control_keys &= ~BUT_RIGHT; break;
				case SDLK_UP:		*control_keys &= ~BUT_UP; break;
				case SDLK_DOWN:		*control_keys &= ~BUT_DOWN; break;
				case SDLK_x:		*control_keys &= ~BUT_SHOOT; break;
				case SDLK_z:		*control_keys &= ~BUT_JUMP; break;
				case SDLK_a:		*control_keys &= ~BUT_SWITCH; break;
				case SDLK_RETURN:
					if ( !(event.key.keysym.mod & KMOD_ALT) )
						*control_keys &= ~BUT_PAUSE; break;
			}
		}
		// Handle joystick input:
		if ( event.type == SDL_JOYAXISMOTION ) {
			// Left-right movement code:
			if (( event.jaxis.axis == 0 ) || ( event.jaxis.axis == 4 )) {
				//xaxis_scale = abs(event.jaxis.value);
				if ( event.jaxis.value < -16384 ) {
					*control_keys |= BUT_LEFT;
					*control_keys &= ~BUT_RIGHT;
				} else if ( event.jaxis.value > 16384 ) {
					*control_keys &= ~BUT_LEFT;
					*control_keys |= BUT_RIGHT;
				} else {
					*control_keys &= ~BUT_LEFT;
					*control_keys &= ~BUT_RIGHT;
				}
			}
			// Up-Down movement code:
			if (( event.jaxis.axis == 1 ) || ( event.jaxis.axis == 5 )) {
				//yaxis_scale = abs(event.jaxis.value);
				if ( event.jaxis.value < -16384 ) {
					*control_keys |= BUT_UP;
					*control_keys &= ~BUT_DOWN;
				} else if ( event.jaxis.value > 16384 ) {
					*control_keys &= ~BUT_UP;
					*control_keys |= BUT_DOWN;
				} else {
					*control_keys &= ~BUT_UP;
					*control_keys &= ~BUT_DOWN;
				}
			}
		}
		if ( event.type == SDL_JOYBUTTONDOWN ) {
			if ( event.jbutton.button == 0) *control_keys |= BUT_JUMP;
			if ( event.jbutton.button == 1) *control_keys |= BUT_PAUSE;
			if ( event.jbutton.button == 2) *control_keys |= BUT_SHOOT;
			if ( event.jbutton.button == 3) *control_keys |= BUT_SWITCH;
		}
		if ( event.type == SDL_JOYBUTTONUP ) {
			if ( event.jbutton.button == 0) *control_keys &= ~BUT_JUMP;
			if ( event.jbutton.button == 1) *control_keys &= ~BUT_PAUSE;
			if ( event.jbutton.button == 2) *control_keys &= ~BUT_SHOOT;
			if ( event.jbutton.button == 3) *control_keys &= ~BUT_SWITCH;
		}

		// This should be updated, but I can't test it in Linux:
		if ( event.type == SDL_JOYHATMOTION ) {
			if ( event.jhat.hat & SDL_HAT_LEFT ) {
				*control_keys |= BUT_LEFT;
				*control_keys &= ~BUT_RIGHT;
			}
			if ( event.jhat.hat & SDL_HAT_RIGHT ) {
				*control_keys &= ~BUT_LEFT;
				*control_keys |= BUT_RIGHT;
			}
			if ( event.jhat.hat & SDL_HAT_UP ) {
				*control_keys |= BUT_UP;
				*control_keys &= ~BUT_DOWN;
			}
			if ( event.jhat.hat & SDL_HAT_DOWN ) {
				*control_keys &= ~BUT_UP;
				*control_keys |= BUT_DOWN;
			}
		}
	}
};
